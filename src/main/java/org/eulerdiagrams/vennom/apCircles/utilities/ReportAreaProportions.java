package org.eulerdiagrams.vennom.apCircles.utilities;import java.io.*;import java.util.*;import java.awt.*;import java.awt.event.*;import java.awt.geom.*;import org.eulerdiagrams.vennom.apCircles.AbstractDiagram;import org.eulerdiagrams.vennom.apCircles.AreaSpecification;import org.eulerdiagrams.vennom.apCircles.ConcreteContour;import org.eulerdiagrams.vennom.apCircles.RegularPolygon;import org.eulerdiagrams.vennom.apCircles.Util;import org.eulerdiagrams.vennom.apCircles.display.APCircleDisplay;import org.eulerdiagrams.vennom.graph.*;import org.eulerdiagrams.vennom.graph.utilities.GraphUtility;/** * Just for quick testing of methods. */public class ReportAreaProportions extends GraphUtility {	public static int polygonResolution = 10000;	private float scalingFactor;/** Trivial constructor. */	public ReportAreaProportions() {		super(KeyEvent.VK_A,"Area Calculation Report",KeyEvent.VK_A);	}	public void apply() {				System.out.println("Area Calculation Report");		report(getGraph());	}		public void report(Graph g) {		ArrayList<ConcreteContour> circleConcreteContours = convertCirclesToCCs(g);				HashMap<String,Double> currentValuesMap = new HashMap<String,Double>();				HashMap<String, Area> zoneAreaMap = ConcreteContour.generateZoneAreas(circleConcreteContours);		for (String zone : zoneAreaMap.keySet()) {			Area area = zoneAreaMap.get(zone);			ArrayList<Polygon> polygons = ConcreteContour.polygonsFromArea(area);			if (zone.equals("")) {				// outer zone				continue;			}			// remove polygons that surround holes in the zone			// we only want polygons where the fill is the zone			// eg. diagram "0 a b ab" where a and b go through each other			// has two polys filled with the zone for both a and b			// the diagram "0 a b" drawn normally has three			// polys for 0 (including border), only one of which			// is filled with 0.			//			// What about holes in holes? Does this happen with			// simple polygons? I don't think so.			ArrayList<Polygon> polysCopy = new ArrayList<Polygon>(polygons);			for (Polygon polygon : polysCopy) {				Point2D insidePoint = ConcreteContour.findPointInsidePolygon(polygon);				if (insidePoint != null && !area.contains(insidePoint)) {					polygons.remove(polygon);				}			}			double totalPolygonArea = 0.0;			for(Polygon p : polygons) {//graphPanel.polygons.add(p);				double scaledPolygonArea = Util.computePolygonArea(p);				double polygonArea= scaledPolygonArea/(scalingFactor*scalingFactor);				totalPolygonArea += polygonArea;			}			currentValuesMap.put(zone,totalPolygonArea);					}				// adjustment for containment		HashMap<String,Double> zoneAreaAdjustmentMap = new HashMap<String, Double>();		for(String z : zoneAreaMap.keySet()) {			if(z.equals("")) {				continue;			}						double containedArea = 0.0;			ArrayList<String> containedZones = findZonesCompletelyContained(new ArrayList<String>(zoneAreaMap.keySet()),z);			for(String zone : containedZones) {				double zoneArea = currentValuesMap.get(zone);				containedArea += zoneArea;			}			zoneAreaAdjustmentMap.put(z,containedArea);					}				double currentTotal = 0.0;		for(String zone : currentValuesMap.keySet()) {			double value = currentValuesMap.get(zone);			currentTotal += value;		}		HashSet<String> allZones = new HashSet<String>(currentValuesMap.keySet());				HashMap<String,Double> requiredValuesMap = getGraphPanel().getSpecification().getSpecification();		allZones.addAll(requiredValuesMap.keySet());		double requiredTotal = 0.0;		for(String zone : requiredValuesMap.keySet()) {			double value = requiredValuesMap.get(zone);			requiredTotal += value;		}				System.out.println("zone actual required error percent");				ArrayList<String> allZonesList = new ArrayList<String>(allZones);		boolean unique = AbstractDiagram.sortZoneList(allZonesList);		if(!unique) {			System.out.println("DUPLICATE ZONES");		}double actualCheck = 0.0;double requiredCheck = 0.0;		for(String zone : allZonesList) {			Double actual = currentValuesMap.get(zone);			if(actual == null) {				actual = 0.0;			}			actual = actual/currentTotal;actualCheck += actual;			Double required = requiredValuesMap.get(zone);			if(required == null) {				required = 0.0;			}			required = required/requiredTotal;requiredCheck += required;			double percentError = Math.abs(100*(required-actual)/required);			if(required == 0) {				percentError = 100.0;			}			percentError = Util.round(percentError, 2);System.out.println("absolute " +zone+" "+currentValuesMap.get(zone)+" "+requiredValuesMap.get(zone));			System.out.println(zone+" "+actual+" "+required+" "+(required-actual)+" "+percentError+"%");					}//System.out.println(actualCheck +" "+requiredCheck+" both should be 1");					}		/**	 * Find the zones in the zone completely inside the given zone at level 1, so	 * no zones inside circles inside zones	 */	public ArrayList<String> findZonesCompletelyContained(ArrayList<String> zoneList, String z) {		ArrayList<String> containedCircles = new ArrayList<String>();				AbstractDiagram ad = new AbstractDiagram(zoneList);		ArrayList<String> contours = AbstractDiagram.findContoursFromZones(zoneList);				for(String circle : contours) {			if(circle.equals(z)) { // circle cannot contain its own zone				continue;			}			if(ad.zoneContainment(z,circle)) {				containedCircles.add(circle);			}		}				ArrayList<String> subCircleContainment = new ArrayList<String>();		for(String c1 : containedCircles) {			for(String c2 : containedCircles) {				if(c1 == c2) {					continue;				}				if(ad.contourContainment(c1, c2)) {					subCircleContainment.add(c2);				}			}		}				ArrayList<String> containedZones = new ArrayList<String>();		for (String zone : zoneList) {			for(String circle : containedCircles) {				if(zone.contains(circle)) {					boolean subCircleFlag = false;					for(String subCircle : subCircleContainment) {						if(zone.contains(subCircle)) {							subCircleFlag = true;							break;						}					}					if(subCircleFlag) {						continue;					}										containedZones.add(zone);					break;				}			}		}				System.out.println("zone "+z+" contains circles "+containedCircles+" subcircles "+subCircleContainment+" zones "+containedZones);				return containedZones;	}	public ArrayList<ConcreteContour> convertCirclesToCCs(Graph g) {		ArrayList<ConcreteContour> circleContours = new ArrayList<ConcreteContour>();		//graphPanel.polygons = new ArrayList<Polygon>();		// scale polygons for best resolution		float biggestRadius = -1;		int i = 0;		for(Node n : g.getNodes()) {			double radius = Double.parseDouble(n.getLabel());			if(radius > biggestRadius) {				biggestRadius = (float)radius;			}			i++;		}		scalingFactor = 1.0E4f/biggestRadius; // value found by experimentation//scalingFactor = 1;//System.out.println("Approximation error ");		for(Node n : g.getNodes()) {			int scaledX = Util.convertToInteger(n.getX()*scalingFactor);			int scaledY = Util.convertToInteger(n.getY()*scalingFactor);						double radius = Double.parseDouble(n.getLabel());						Polygon p = RegularPolygon.generateRegularPolygon(scaledX, scaledY, radius*scalingFactor, polygonResolution);						ConcreteContour cc = new ConcreteContour(n.getContour(), p);			circleContours.add(cc);			// graphPanel.polygons.add(p);//report approximation error						double actualArea = (float)(Math.PI*radius*radius);//System.out.println("scaledActualArea "+(actualArea*scalingFactor*scalingFactor));			float scaledPolygonArea = Util.computePolygonAreaFloat(p);//System.out.println(n.getContour()+" scaledPolygonArea "+scaledPolygonArea);			float polygonArea= scaledPolygonArea/(scalingFactor*scalingFactor);			double percentError = 100*(polygonArea-actualArea)/actualArea;			if(Math.abs(percentError) > 0.1) {				System.out.println(n.getContour()+" has circle area error > 0.1% is: "+percentError+"% actual area: "+actualArea+" polygon Area: "+polygonArea);			}		}				return circleContours;	}	}