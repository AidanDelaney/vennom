package org.eulerdiagrams.vennom.graph;import java.util.*;import java.io.*;import javax.swing.*;import java.awt.*;import java.awt.geom.*;/** * A node in a graph. This implements a simple labeled node for a graph. * <p> * It contains some additional fields for helping when writing algorithms, the * boolean {@link #visited}, a flag for indicating that a node has been traversed * and the list {@link #path} for indicating some sort of route to the * node, which also allows a test (null) to see if the node has been visited. * <p> * A redundant structure is used to speed up the access of neighbouring * nodes. This is in the form of the two Hash Sets, {@link #edgesFrom} and * {@link #edgesTo}, which are modified when edges are created, deleted or modified. * * @see Graph * @see Edge * @author Peter Rodgers */public class Node implements Serializable {@Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + ((centre == null) ? 0 : centre.hashCode());        result = prime * result + ((contour == null) ? 0 : contour.hashCode());	// Node hashCode can't use Edges as edges also contain nodes, and that's cyclical.//        result = prime * result//                + ((edgesFrom == null) ? 0 : edgesFrom.hashCode());//        result = prime * result + ((edgesTo == null) ? 0 : edgesTo.hashCode());        result = prime * result + ((label == null) ? 0 : label.hashCode());        result = prime * result + ((match == null) ? 0 : match.hashCode());        result = prime * result                + ((preciseCentre == null) ? 0 : preciseCentre.hashCode());        long temp;        temp = Double.doubleToLongBits(score);        result = prime * result + (int) (temp ^ (temp >>> 32));        result = prime * result + ((shape == null) ? 0 : shape.hashCode());        result = prime * result + ((type == null) ? 0 : type.hashCode());        result = prime * result + (visited ? 1231 : 1237);        return result;    }	/**	 * Nodes are equal if they contain the same data regardless of their connectivity i.e. two nodes are equal even if	 * they have different to and from edges.	 *	 * @param obj	 * @return     */    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Node other = (Node) obj;        if (centre == null) {            if (other.centre != null)                return false;        } else if (!centre.equals(other.centre))            return false;        if (contour == null) {            if (other.contour != null)                return false;        } else if (!contour.equals(other.contour))            return false;        /*         * See description of equals above.        if (edgesFrom == null) {            if (other.edgesFrom != null)                return false;        } else if (!edgesFrom.equals(other.edgesFrom))            return false;        if (edgesTo == null) {            if (other.edgesTo != null)                return false;        } else if (!edgesTo.equals(other.edgesTo))            return false;        */        if (label == null) {            if (other.label != null)                return false;        } else if (!label.equals(other.label))            return false;        if (match == null) {            if (other.match != null)                return false;        } else if (!match.equals(other.match))            return false;        if (preciseCentre == null) {            if (other.preciseCentre != null)                return false;        } else if (!preciseCentre.equals(other.preciseCentre))            return false;        if (Double.doubleToLongBits(score) != Double                .doubleToLongBits(other.score))            return false;        if (shape == null) {            if (other.shape != null)                return false;        } else if (!shape.equals(other.shape))            return false;        if (type == null) {            if (other.type != null)                return false;        } else if (!type.equals(other.type))            return false;        if (visited != other.visited)            return false;        return true;    }/** * Redundant data giving the edges out of this node to speed up algorithms. * It needs to be maintained by edges as they are connected and * removed from this node. The node should not alter this member. * The collection should have unique content so that an edge must appear only once. */	protected ArrayList<Edge> edgesFrom = new ArrayList<Edge>();/** * Redundant data giving the edges into this node to speed up algorithms. * It needs to be  maintained by edges as they are connected and * removed from this node. The node should not alter this member. * The collection should have unique content so that an edge must appear only once. */	protected ArrayList<Edge> edgesTo = new ArrayList<Edge>();	protected String label = "";	protected String contour= "";/** Type, must be present. */	protected NodeType type = Graph.DEFAULT_NODE_TYPE;/** Coordinate of the middle of the node on the screen. */	protected Point centre = new Point(0,0);/** For AP circle work - allows a more precise centre to be stored */	protected Point2D.Double preciseCentre = null;/** This flag that can be set if the node has been traversed in an algorithm. */	protected boolean visited = false;/** A variable for use in graph algorithms. This can be used to score nodes. */	protected double score = 0.0;/** * A variable for use in graph algorithms. General Use, but can be used for * pointing at nodes in matching algorithms. */	protected Object match = null;/** The last generated shape object for this node */	Shape shape = null;/** The animation X distance on each iteration. */	public static final int ANIMATEXINCREMENT = 3;/** The animation Y distance on each iteration. */	public static final int ANIMATEYINCREMENT = 1;/** Minimal constructor. It creates an unlabeled node. */	public Node() {}/** Creates a labelled node */	public Node(String inLabel) {		setLabel(inLabel);	}/** Creates a node at the given point. */	public Node(Point inCentre) {		setCentre(inCentre);	}/** Creates a node of the given type. */	public Node(NodeType inType) {		setType(inType);	}/** Creates a labeled node of the given type. */	public Node(String inLabel, NodeType inType) {		setLabel(inLabel);		setType(inType);	}/** Creates a node of the given type at the given point. */	public Node(NodeType inType, Point inCentre) {		setType(inType);		setCentre(inCentre);	}/** Creates a labeled node at the given point. */	public Node(String inLabel, Point inCentre) {		setLabel(inLabel);		setCentre(inCentre);	}/** Creates a labelled node of the given type at the given point. */	public Node(String inLabel, NodeType inType, Point inCentre) {		setLabel(inLabel);		setType(inType);		setCentre(inCentre);	}	public ArrayList<Edge> getEdgesFrom() {return edgesFrom;}	public ArrayList<Edge> getEdgesTo() {return edgesTo;}	public String getLabel() {return label;}	public String getContour() {return contour;}	public NodeType getType() {return type;}	public Point getCentre() {return centre;}	public int getX() {return getCentre().x;}	public int getY() {return getCentre().y;}	public boolean getVisited() {return visited;}	public double getScore() {return score;}	public Object getMatch() {return match;}	/** Set externally, if not set is null */	public Point2D.Double getPreciseCentre() {return preciseCentre;}	public double getPreciseRadius() {return score;}	public void setLabel(String inLabel) {label=inLabel;}	public void setContour(String inContour) {contour=inContour;}	public void setType(NodeType inType) {type=inType;}	public void setCentre(Point inCentre) {centre=inCentre;}	public void setVisited(boolean inVisited) {visited = inVisited;}	public void setScore(double inScore) {score = inScore;}	public void setMatch(Object inMatch) {match = inMatch;}	protected boolean addEdgeFrom(Edge e) {return(edgesFrom.add(e));}	protected boolean addEdgeTo(Edge e) {return(edgesTo.add(e));}/** This should only be used by an edge method. */	protected boolean removeEdgeFrom(Edge e) {return(edgesFrom.remove(e));}/** This should only be used by an edge method. */	protected boolean removeEdgeTo(Edge e) {return(edgesTo.remove(e));}	/** Accessed externally */	public void setPreciseCentre(Point2D.Double p) {preciseCentre = p;}/** Set the X part of the node centre only. */	public void setX(int inX) {setCentre(new Point(inX,centre.y));}/** Set the Y part of the node centre only. */	public void setY(int inY) {setCentre(new Point(centre.x, inY));}/** Set the X part of the node centre only and animate the changes. */	public void setX(int inX, JPanel p) {		while (centre.x > inX) {			setCentre(new Point(centre.x-ANIMATEXINCREMENT,centre.y));			p.update(p.getGraphics());		}		while (centre.x < inX) {			setCentre(new Point(centre.x+ANIMATEXINCREMENT,centre.y));			p.update(p.getGraphics());		}// a final move, in case the increments are uneven		setCentre(new Point(inX,centre.y));		p.update(p.getGraphics());	}/** Set the Y part of the node centre only and animate the changes. */	public void setY(int inY, JPanel p) {		while (centre.y > inY) {			setCentre(new Point(centre.x,centre.y-ANIMATEYINCREMENT));			p.update(p.getGraphics());		}		while (centre.y < inY) {			setCentre(new Point(centre.x,centre.y+ANIMATEYINCREMENT));			p.update(p.getGraphics());		}// a final move, in case the increments are uneven		setCentre(new Point(centre.x,inY));		p.update(p.getGraphics());	}/** * Gives all the connecting edges. * @return all the connecting edges, without duplicates. */	public HashSet<Edge> connectingEdges() {		HashSet<Edge> edges = new HashSet<Edge>(getEdgesFrom());		edges.addAll(getEdgesTo());		return(edges);	}/** * Gives the unvisited connecting edges, without duplicates. The predicate * is based on the visited field of the edge. */	public HashSet<Edge> unvisitedConnectingEdges() {		HashSet<Edge> edges = new HashSet<Edge>();		Collection<Edge> allEdges = connectingEdges();		for(Edge e : allEdges) {			if(!e.getVisited()) {				edges.add(e);			}		}		return(edges);	}/** * Gives all the connecting edges from this node to the argument node. * @return all the connecting edges to the argument node, without duplicates. */	public HashSet<Edge> connectingEdges(Node n) {		HashSet<Edge> ret = new HashSet<Edge>();// needs to be done twice, once for from list, once for to list		for(Edge e : edgesFrom) {			if(e.getTo() == n) {				ret.add(e);			}		}		for(Edge e : edgesTo) {			if(e.getFrom() == n) {				ret.add(e);			}		}		return ret;	}/** * Gives all the connecting nodes without duplicates. * Or, put another way all the neigbouring nodes. * Duplicates could be due to self sourcing edges or parallel nodes, and are removed. * @return all the neigbouring nodes, without duplicates. */	public HashSet<Node> connectingNodes() {		HashSet<Node> nodes = new HashSet<Node>(degree());// iterate through the edges		for(Edge e : connectingEdges()) {			Node n;// get the node at the right end (this test copes with self sourcing nodes)			if(e.getTo() == this) {				n = e.getFrom();			} else {				n = e.getTo();			}//check for duplicates			if(!nodes.contains(n)) {				nodes.add(n);			}		}		return(nodes);	}/** * Gives all the unvisited connecting nodes, according to the visited field. * @return all unvisited neighbouring nodes, without duplicates. */	public HashSet<Node> unvisitedConnectingNodes() {		HashSet<Node> nodes = new HashSet<Node>(degree());// iterate through the connecting nodes		for(Node n : connectingNodes()) {			if(!n.getVisited()) {				nodes.add(n);			}		}		return(nodes);	}/** Gives the number of connecting edges. */	public int degree() {		return(getEdgesFrom().size()+getEdgesTo().size());	}/** * Gives a new shape object repsenting the node. At the moment * rectangles and ellipses are supported */	public Shape generateShape() {		int height = type.getHeight();		int width = type.getWidth();		if(type.getShapeString().equals("Ellipse")) {			shape = new Ellipse2D.Double(centre.x-width/2,centre.y-height/2,width,height);		 } else {			shape = new Rectangle2D.Double(centre.x-width/2,centre.y-height/2,width,height);		}		return(shape);	}/** * Returns the shape object representing the node, or if * there is none, generate a new shape. */	public Shape shape() {		if(shape == null) {			generateShape();		}		return(shape);	}/** * Check consistency- ensure all redundant connection data matches * with edge to and from. Principally used by the Graph method * {@link Graph#consistent}. */	public boolean consistent(Graph g) {// needs to be done twice, once for from list, once for to list		for(Edge e : edgesFrom) {// test for edge having wrong data			if(e.getFrom() != this) {				return false;			}			if(!g.getEdges().contains(e)) {				return false;			}		}		for(Edge e : edgesTo) {// test for edge having wrong data			if(e.getTo() != this) {				return false;			}			if(!g.getEdges().contains(e)) {				return false;			}		}		return true;	}/** Gives a textual representation of the node, at the moment just the label. */	public String toString() {		return(label);	}}