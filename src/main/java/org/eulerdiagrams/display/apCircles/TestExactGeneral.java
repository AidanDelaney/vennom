package org.eulerdiagrams.display.apCircles;import java.io.*;import java.util.*;import java.awt.Polygon;import java.awt.event.*;import java.awt.geom.Area;import java.awt.geom.Point2D;import org.eulerdiagrams.display.graph.GraphUtility;import org.eulerdiagrams.vennom.apCircles.*;import org.eulerdiagrams.vennom.apCircles.drawers.*;import org.eulerdiagrams.vennom.graph.*;/** * Just for quick testing of methods. */public class TestExactGeneral extends GraphUtility implements Serializable {	public int minNumberOfCircles = 3;	public int maxNumberOfCircles = 8;	public int zoneAreaMin = 100;	public int zoneAreaMax = 10000;		public int numberOfTests = 100;		AreaSpecification as = null;	public double idealMultipiler = 0.05;	public double separatorMultiplier = 20000.0;	public double containmentMultiplier = 0.01;	public double f = 1.0;		public double zoneErrorTotal = 0;	public double areaErrorTotal = 0;		public long diagramSeed = 256;	private static final long serialVersionUID = 1L;	public TestExactGeneral() {		super(KeyEvent.VK_2,"Test Exact General",KeyEvent.VK_2);	}	public TestExactGeneral(long seed) {		super(KeyEvent.VK_2,"Test Exact General",KeyEvent.VK_2);		diagramSeed = seed;	}	public void setDiagramSeed(long l) {diagramSeed = l;}	public void apply() {		zoneErrorTotal = 0;		areaErrorTotal = 0;				as = null;		Graph g = null;		Random random = new Random(100);		int i = 0;		for(int diagramNo = 1; diagramNo <= numberOfTests; diagramNo++) {			int numberOfCircles = random.nextInt(1+maxNumberOfCircles-minNumberOfCircles);			numberOfCircles += minNumberOfCircles;//System.out.println("diagram "+diagramNo+" numberOfCircles "+numberOfCircles+" i "+i);			String beforeFileName = "before"+diagramNo+".svg";			while(g == null) {				i++;								as = createExactGeneralSpecification(numberOfCircles, diagramNo*diagramSeed+i, beforeFileName);								if(as.getAbstractDiagram().findIntersectionGroups().size() > 1) { // no disconnected diagrams					 g = null;					 continue;				}				g = as.generateGeneralAugmentedIntersectionGraph();				if(g != null && g.getEdges().size() == 0) { // no trivial diagrams					g = null;					 continue;				}			}						String asString = as.toString();			asString = asString.replace('\n', ':');			long startTime = System.currentTimeMillis();			runGeneralTest(as);			double generalTime = (System.currentTimeMillis()-startTime)/1000.0;						String afterFileName = "after"+diagramNo+".svg";			File file = new File(afterFileName);			getGraphPanel().saveCirclesSVG(file);			boolean printme = false;if(printme){		System.out.print("general\t"+asString+"\t");	System.out.println(report(as,getGraphPanel().getGraph())+"\t"+generalTime);}			findErrors(as,getGraphPanel().getGraph());			zoneErrorTotal += zoneErrors;			areaErrorTotal += areaErrors;			g = null;		}	}		protected static double zoneErrors = 0;	protected static double areaErrors = 0;		public static void findErrors(AreaSpecification ad, Graph g) {				zoneErrors = 0;		areaErrors = 0;		HashMap<String,Double> errorMap = new HashMap<String,Double>();		ArrayList<String> missingZones = new ArrayList<String>();		ArrayList<String> additionalZones = new ArrayList<String>();		Util.findErrors(ad,g, errorMap, missingZones, additionalZones);		zoneErrors += missingZones.size()+additionalZones.size();//System.out.println("missing "+missingZones);//System.out.println("additional "+additionalZones);//System.out.println("errorTotal "+errorTotal);		for(String zone : errorMap.keySet()) {			areaErrors += errorMap.get(zone);		}	}		public static String report(AreaSpecification ad, Graph g) {		HashMap<String,Double> errorMap = new HashMap<String,Double>();		ArrayList<String> missingZones = new ArrayList<String>();		ArrayList<String> additionalZones = new ArrayList<String>();		Util.findErrors(ad,g, errorMap, missingZones, additionalZones);		String ret = "";		ret += missingZones.size()+additionalZones.size();//System.out.println("missing "+missingZones);//System.out.println("additional "+additionalZones);//System.out.println("errorTotal "+errorTotal);		double errorTotal = 0.0;		for(String zone : errorMap.keySet()) {			errorTotal += errorMap.get(zone);		}		ret += "\t"+errorTotal;				return ret;	}	protected void runGeneralTest(AreaSpecification as) {		Graph g = as.generateGeneralAugmentedIntersectionGraph();		getGraphPanel().setGraph(g);		GeneralAPForceModel fm = new GeneralAPForceModel();				fm.setIdealMultiplier(this.idealMultipiler);		fm.setSeparatorMultiplier(this.separatorMultiplier);		fm.setContainmentMultiplier(this.containmentMultiplier);		fm.setF(this.f);		fm.setGraphPanel(getGraphPanel());		fm.setRandomize(false);		fm.setAnimateFlag(false);		fm.layout();	}			public AreaSpecification createExactGeneralSpecification(int circleCount, long seed,String fileName) {				AreaSpecification areaSpecification = exactRandomDiagramFactory(50,50,300,300,15,100,circleCount,seed,fileName);		return areaSpecification;	}		public static AreaSpecification exactRandomDiagramFactory(int minX, int minY, int maxX, int maxY, int minRadius, int maxRadius, int circleCount, long seed, String fileName) {		ArrayList<Integer> xList = new ArrayList<Integer>();		ArrayList<Integer> yList = new ArrayList<Integer>();		ArrayList<Double> radiusList = new ArrayList<Double>();		Random random = new Random(seed);		for(int i = 0; i < circleCount; i++) {			int x = random.nextInt(1+maxX-minX);			x += minX;			int y = random.nextInt(1+maxY-minY);			y += minY;			double radius = random.nextInt(1+maxRadius-minRadius);			radius += minRadius;						xList.add(x);			yList.add(y);			radiusList.add(radius);		}		AreaSpecification as = findAreaSpecificationFromCircles(xList,yList,radiusList);				if(fileName != null && fileName.length() > 0) {			File file = new File(fileName);			String svg = "<svg  width=\""+500+"\" height=\""+500+"\">\n";			for (int i = 0; i < circleCount; i++) {				double x = xList.get(i);				double y = yList.get(i);				double r = radiusList.get(i);				svg += "\t<circle cx=\""+x+"\" cy=\""+y+"\" r=\""+r+"\" fill=\"none\" stroke=\"black\" stroke-width=\"2\" />\n";			}						svg += "</svg>";			try {				BufferedWriter b = new BufferedWriter(new FileWriter(file));		// save the nodes				b.write(svg);				b.newLine();				b.close();			}			catch(IOException e){				System.out.println("An IO exception occured when saving svg in exactRandomDiagramFactory("+file.getName()+"\n"+e+"\n");			}		}				return as;	}	private static AreaSpecification findAreaSpecificationFromCircles(ArrayList<Integer> xList, ArrayList<Integer> yList, ArrayList<Double> radiusList) {		Graph g = new Graph();		for(int i = 0; i < radiusList.size(); i++) {			Double radius = radiusList.get(i);			int x = xList.get(i);			int y = yList.get(i);			Node n = new Node(radius.toString());			n.setX(x);			n.setY(y);			n.setScore(radius);			Character label = (char)('a'+i);			n.setContour(label.toString());			g.addNode(n);//System.out.print(label+" "+x+":"+y+":"+radius+" ");		}//System.out.println();				ArrayList<ConcreteContour> circleConcreteContours = 				AreaSpecification.convertCirclesToCCs(g,						                              AreaSpecification.polygonResolution);		HashMap<String,Double> currentValuesMap = new HashMap<String,Double>();		HashMap<String, Area> zoneAreaMap = ConcreteContour.generateZoneAreas(circleConcreteContours);		for (String zone : zoneAreaMap.keySet()) {			Area area = zoneAreaMap.get(zone);				ArrayList<Polygon> polygons = ConcreteContour.polygonsFromArea(area);			if (zone.equals("")) {				// outer zone				continue;			}				// remove polygons that surround holes in the zone			// we only want polygons where the fill is the zone			// eg. diagram "0 a b ab" where a and b go through each other			// has two polys filled with the zone for both a and b			// the diagram "0 a b" drawn normally has three			// polys for 0 (including border), only one of which			// is filled with 0.			//			// What about holes in holes? Does this happen with			// simple polygons? I don't think so.			ArrayList<Polygon> polysCopy = new ArrayList<Polygon>(polygons);			for (Polygon polygon : polysCopy) {				Point2D insidePoint = ConcreteContour.findPointInsidePolygon(polygon);				if (insidePoint != null && !area.contains(insidePoint)) {					polygons.remove(polygon);				}			}				double totalPolygonArea = 0.0;			for(Polygon p : polygons) {	//graphPanel.polygons.add(p);				double scaledPolygonArea = Util.computePolygonArea(p);				double polygonArea= scaledPolygonArea/(AreaSpecification.scalingFactor*AreaSpecification.scalingFactor);				totalPolygonArea += polygonArea;			}			currentValuesMap.put(zone,totalPolygonArea);		}						ArrayList<String> zoneList = new ArrayList<String>(currentValuesMap.keySet());		AbstractDiagram.sortZoneList(zoneList);		AbstractDiagram ad = new AbstractDiagram(zoneList);				AreaSpecification ret = new AreaSpecification(ad,currentValuesMap);				return ret;	}		}